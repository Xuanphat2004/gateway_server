/* modbus_tcp_server.c
 * TCP server receives Modbus TCP requests from clients,
 * maps TCP address to RTU address via SQLite,
 * then sends a JSON request to the RTU server via Redis Pub/Sub.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sqlite3.h>
#include <hiredis/hiredis.h>

#define PORT 1502
#define REDIS_CHANNEL "modbus_request"

// Xử lý gói tin từ client TCP
void handle_tcp_client(int client_sock, redisContext *redis, sqlite3 *db) 
{
    uint8_t buffer[260];
    int bytes = recv(client_sock, buffer, sizeof(buffer), 0);
    if (bytes <= 0) 
    {
        perror("");
        return;
    }

    printf("\nReceived TCP packet: ");
    for (int i = 0; i < bytes; i++) printf("%02X", buffer[i]);
    printf("\n");

    if (bytes < 12) {
        printf("Invalid packet: too short\n");
        return;
    }

    // Phân tích gói tin Modbus TCP
    uint16_t transaction_id = (buffer[0] << 8) | buffer[1];
    uint8_t unit_id = buffer[6];
    uint8_t function = buffer[7];
    uint16_t start_address = (buffer[8] << 8) | buffer[9];
    uint16_t quantity = (buffer[10] << 8) | buffer[11];

    printf("Parsed -> Unit ID: %d, Function: %d, TCP Address: %d, Quantity: %d\n",
           unit_id, function, start_address, quantity);

    // Truy vấn SQLite ánh xạ TCP -> RTU
    sqlite3_stmt *stmt;
    const char *sql = "SELECT rtu_id, rtu_address FROM mapping WHERE tcp_address = ?";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) {
        fprintf(stderr, "SQLite prepare error: %s\n", sqlite3_errmsg(db));
        return;
    }
    sqlite3_bind_int(stmt, 1, start_address);

    if (sqlite3_step(stmt) == SQLITE_ROW) {
        int rtu_id = sqlite3_column_int(stmt, 0);
        int rtu_address = sqlite3_column_int(stmt, 1);

        printf("Mapped RTU -> ID: %d, Address: %d\n", rtu_id, rtu_address);

        // Đóng gói JSON gửi xuống RTU Server qua Redis
        char payload[256];
        snprintf(payload, sizeof(payload),
                 "{\"transaction_id\":%d,\"rtu_id\":%d,\"rtu_address\":%d,\"function\":%d,\"quantity\":%d}",
                 transaction_id, rtu_id, rtu_address, function, quantity);

        redisReply *reply = redisCommand(redis, "PUBLISH %s %s", REDIS_CHANNEL, payload);
        if (reply) freeReplyObject(reply);

        printf("Published request to RTU server: %s\n", payload);
    } else {
        printf("No mapping found for TCP address: %d\n", start_address);
    }

    sqlite3_finalize(stmt);
}

int main() {
    // Kết nối Redis
    redisContext *redis = redisConnect("127.0.0.1", 6379);
    if (redis == NULL || redis->err) {
        printf("Redis connection error\n");
        return 1;
    }
    printf("Connected to Redis successfully\n");

    // Kết nối SQLite
    sqlite3 *db;
    if (sqlite3_open("modbus_mapping.db", &db)) {
        fprintf(stderr, "Cannot open database: %s\n", sqlite3_errmsg(db));
        return 1;
    }
    printf("Connected to SQLite database successfully\n");

    // Tạo socket TCP server
    int listenfd = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in addr = {0};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(PORT);
    addr.sin_addr.s_addr = INADDR_ANY;

    bind(listenfd, (struct sockaddr *)&addr, sizeof(addr));
    listen(listenfd, 5);

    fd_set master, readfds;
    FD_ZERO(&master);
    FD_SET(listenfd, &master);
    int fdmax = listenfd;

    printf("TCP Server listening on port %d...\n", PORT);

    while (1) {
        readfds = master;
        if (select(fdmax + 1, &readfds, NULL, NULL, NULL) < 0) continue;

        for (int i = 0; i <= fdmax; ++i) {
            if (FD_ISSET(i, &readfds)) {
                if (i == listenfd) {
                    int newfd = accept(listenfd, NULL, NULL);
                    if (newfd >= 0) {
                        FD_SET(newfd, &master);
                        if (newfd > fdmax) fdmax = newfd;
                    }
                } else {
                    handle_tcp_client(i, redis, db);
                    close(i);
                    FD_CLR(i, &master);
                }
            }
        }
    }

    // Giải phóng tài nguyên
    sqlite3_close(db);
    redisFree(redis);
    return 0;
}

