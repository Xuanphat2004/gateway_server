#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <modbus/modbus.h>
#include <hiredis/hiredis.h>

#define REDIS_CHANNEL "modbus_request"
#define REDIS_RESPONSE "modbus_response"
#define SERIAL_PORT "/dev/ttyS1"
#define BAUDRATE 9600
#define TIMEOUT_SEC 0
#define TIMEOUT_USEC 500000   // 500ms timeout

void process_request(const char* message) {
    int slave_id = 1;
    int reg_addr = 0;
    int reg_count = 1;

    // Parse message (giả định định dạng: "1:100:2" → slave_id:reg_addr:reg_count)
    sscanf(message, "%d:%d:%d", &slave_id, &reg_addr, &reg_count);

    // Khởi tạo modbus RTU context
    modbus_t *ctx = modbus_new_rtu(SERIAL_PORT, BAUDRATE, 'N', 8, 1);
    if (ctx == NULL) {
        perror("Unable to create RTU context");
        return;
    }

    modbus_set_slave(ctx, slave_id);
    modbus_set_response_timeout(ctx, TIMEOUT_SEC, TIMEOUT_USEC);

    if (modbus_connect(ctx) == -1) {
        perror("Connection failed");
        modbus_free(ctx);
        return;
    }

    uint16_t tab_reg[64];
    int rc = modbus_read_registers(ctx, reg_addr, reg_count, tab_reg);
    if (rc == -1) {
        perror("Modbus read failed");
        modbus_close(ctx);
        modbus_free(ctx);
        return;
    }

    // Gửi kết quả lên Redis
    redisContext *redis = redisConnect("127.0.0.1", 6379);
    if (redis == NULL || redis->err) {
        printf("Redis connection error\n");
        modbus_close(ctx);
        modbus_free(ctx);
        return;
    }
    printf("Connected to Redis successfully\n");

    char result[256];
    snprintf(result, sizeof(result), "%d", tab_reg[0]);  // chỉ gửi giá trị đầu tiên
    redisCommand(redis, "PUBLISH %s %s", REDIS_RESPONSE, result);

    redisFree(redis);
    modbus_close(ctx);
    modbus_free(ctx);
}

int main() {
    redisContext *redis = redisConnect("127.0.0.1", 6379);
    if (redis == NULL || redis->err) {
        printf("Failed to connect to Redis\n");
        return 1;
    }

    redisReply *reply = redisCommand(redis, "SUBSCRIBE %s", REDIS_CHANNEL);
    freeReplyObject(reply);

    while (1) {
        redisReply *msg;
        if (redisGetReply(redis, (void **)&msg) == REDIS_OK && msg) {
            if (strcmp(msg->element[0]->str, "message") == 0) {
                const char* payload = msg->element[2]->str;
                printf("Received RTU request: %s\n", payload);
                process_request(payload);
            }
            freeReplyObject(msg);
        } else {
            printf("Redis disconnected.\n");
            break;
        }
    }

    redisFree(redis);
    return 0;
}

